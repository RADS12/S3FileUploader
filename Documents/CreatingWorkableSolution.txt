Creating a Workable .NET S3 File Uploader Solution - Step by Step Guide
================================================================================

Date: September 26, 2025
Project: S3FileUploader - .NET Web API with AWS ECS Fargate Deployment

================================================================================
1. INITIAL SETUP - Creating .gitignore for .NET Project
================================================================================

COMMAND: Created comprehensive .gitignore file
WHY: Exclude build artifacts, IDE files, and sensitive data from version control
RESULT: Successfully created .gitignore with comprehensive rules for .NET projects
- Excluded build folders (**/bin/, **/obj/)
- Excluded Visual Studio files (.vs/, *.user)
- Excluded environment files (.env)
- Added AWS and Terraform exclusions

================================================================================
2. TERRAFORM ORGANIZATION - Modularizing Infrastructure
================================================================================

COMMAND: Refactored monolithic main.tf into modular files
WHY: Improve maintainability, readability, and organization of infrastructure code
RESULT: Successfully created 9 modular Terraform files:
- providers.tf - AWS provider configuration
- variables.tf - Input variables and configuration
- s3.tf - S3 bucket data source
- ecr.tf - ECR repository for Docker images
- iam.tf - IAM roles and policies
- locals.tf - Local values and computed image URI
- docker.tf - Docker build and push automation
- ecs-fargate.tf - ECS Fargate service with load balancer
- outputs.tf - Output values for reference

================================================================================
3. DOCKER OPTIMIZATION - Reducing Build Context
================================================================================

COMMAND: Created optimized .dockerignore file
WHY: Docker build context was 532MB, causing slow builds and large image transfers
RESULT: Reduced build context from 532MB to 846B
- Excluded unnecessary files (bin/, obj/, .git/, etc.)
- Improved build performance significantly
- Reduced network transfer time to ECR

ERROR ENCOUNTERED: Initial Docker builds were extremely slow
SOLUTION: Added comprehensive .dockerignore with proper exclusions
COMMAND USED: Created .dockerignore with build artifacts and IDE file exclusions

================================================================================
4. AWS APP RUNNER DEPLOYMENT ATTEMPT
================================================================================

COMMAND: terraform apply (initial attempt with App Runner)
WHY: Deploy containerized .NET API using AWS App Runner
ERROR: "Subscription limit exceeded" - App Runner not available in account
SOLUTION: Switch to ECS Fargate as alternative container hosting service
EXPLANATION: App Runner has subscription limits, ECS Fargate provides similar serverless container hosting

================================================================================
5. ECS FARGATE MIGRATION - Container Service Switch
================================================================================

COMMAND: Created ecs-fargate.tf with ECS service definition
WHY: Replace App Runner with ECS Fargate for serverless container hosting
RESULT: Successfully configured ECS Fargate infrastructure:
- ECS Cluster for container orchestration
- ECS Task Definition with container specifications
- Application Load Balancer for traffic routing
- Security groups for network access control

================================================================================
6. DOCKER BUILD AND ECR PUSH
================================================================================

COMMAND: terraform apply (with Docker build automation)
WHY: Build Docker image and push to ECR repository
RESULT: Successfully built and pushed Docker image
- Image tagged as "dev"
- Pushed to ECR: 675016865089.dkr.ecr.us-east-2.amazonaws.com/file-uploader-api:dev
- Automated via Terraform null_resource with local-exec

================================================================================
7. PORT PERMISSION ERROR RESOLUTION
================================================================================

COMMAND: aws logs get-log-events (container logs inspection)
WHY: Containers were failing to start, needed to diagnose the issue
ERROR: "Permission denied" when binding to port 80
ROOT CAUSE: Non-root user in container cannot bind to privileged ports (<1024)
SOLUTION: Changed container port from 80 to 8080
COMMANDS USED:
- Updated Dockerfile to expose port 8080
- Modified ECS task definition container port to 8080
- Updated ASPNETCORE_URLS environment variable to http://+:8080
EXPLANATION: Ports below 1024 require root privileges, but containers run as non-root for security

================================================================================
8. IAM ROLE TRUST POLICY FIXES
================================================================================

COMMAND: terraform apply (IAM role updates)
WHY: ECS tasks require different trust policies than App Runner
ERROR: ECS tasks couldn't assume IAM roles due to incorrect trust policies
SOLUTION: Updated IAM trust policies to support both App Runner and ECS
COMMANDS USED: Modified trust policy in iam.tf to include both service principals:
- ecs-tasks.amazonaws.com (for ECS)
- apprunner.amazonaws.com (for App Runner compatibility)

================================================================================
9. TARGET GROUP DEPENDENCY CONFLICTS
================================================================================

COMMAND: terraform apply (ECS service with load balancer)
WHY: Deploy ECS service with proper load balancer integration
ERROR: Target group conflicts between old (port 80) and new (port 8080) configurations
SOLUTION: Manual AWS CLI operations to resolve dependencies
COMMANDS USED:
1. aws elbv2 delete-target-group --target-group-arn [old-arn]
   - Removed old port 80 target group
2. aws elbv2 create-target-group --name file-uploader-api-port8080 --port 8080
   - Created new target group for port 8080
3. aws elbv2 modify-listener --listener-arn [listener-arn] --default-actions Type=forward,TargetGroupArn=[new-arn]
   - Updated listener to forward to new target group

================================================================================
10. TERRAFORM STATE MANAGEMENT
================================================================================

COMMAND: terraform state rm aws_lb_target_group.api
WHY: Remove old target group from Terraform state to allow import of manually created one
RESULT: Successfully removed resource from state

COMMAND: terraform import aws_lb_target_group.api [target-group-arn]
WHY: Import manually created target group into Terraform state for management
RESULT: Successfully imported new target group with port 8080 configuration

================================================================================
11. SECURITY GROUP CONFIGURATION ERROR
================================================================================

COMMAND: Test-NetConnection -ComputerName [load-balancer-dns] -Port 80
WHY: Test external connectivity to load balancer
ERROR: Connection timeout - port 80 not accessible from internet
ROOT CAUSE: Load balancer using ECS security group that only allowed port 8080
SOLUTION: Created separate security groups for ALB and ECS
COMMANDS USED:
1. Created aws_security_group.alb - allows inbound port 80 from internet
2. Modified aws_security_group.ecs - allows inbound port 8080 from ALB only
3. Updated aws_lb.api to use ALB security group
EXPLANATION: Proper security segmentation - ALB accepts public traffic on port 80, forwards to ECS on port 8080

================================================================================
12. FINAL DEPLOYMENT SUCCESS
================================================================================

COMMAND: terraform apply (final configuration)
WHY: Apply all security group and networking fixes
RESULT: Successful deployment with full functionality

VERIFICATION COMMANDS:
1. Test-NetConnection -ComputerName [load-balancer-dns] -Port 80
   - RESULT: Connection successful
2. Invoke-RestMethod -Uri "http://[load-balancer-dns]/swagger/index.html"
   - RESULT: Swagger UI loaded successfully
3. aws ecs describe-services --cluster file-uploader-api --services file-uploader-api
   - RESULT: RunningCount: 1, DesiredCount: 1, Status: ACTIVE
4. aws elbv2 describe-target-health --target-group-arn [target-group-arn]
   - RESULT: Target healthy

================================================================================
FINAL ARCHITECTURE SUMMARY
================================================================================

SUCCESSFUL DEPLOYMENT COMPONENTS:
✅ .NET 9.0 Web API containerized with Docker
✅ AWS ECR for container image storage
✅ AWS ECS Fargate for serverless container hosting
✅ Application Load Balancer for HTTP traffic routing (port 80 → 8080)
✅ Proper security groups (ALB: public port 80, ECS: internal port 8080)
✅ IAM roles for ECS execution and S3 access
✅ CloudWatch logging for monitoring
✅ S3 integration for file upload functionality

ACCESS ENDPOINTS:
- API Base URL: http://file-uploader-api-1896670076.us-east-2.elb.amazonaws.com
- Swagger UI: http://file-uploader-api-1896670076.us-east-2.elb.amazonaws.com/swagger/index.html
- API Endpoints:
  * POST /api/FileUpload/upload (multipart file upload)
  * GET /api/FileUpload/download-url/{key} (generate S3 presigned URL)

KEY LESSONS LEARNED:
1. Non-root containers cannot bind to privileged ports (<1024)
2. Load balancer and ECS tasks need separate security groups for proper traffic flow
3. Target group dependencies require careful management during infrastructure changes
4. Docker build context optimization significantly improves deployment speed
5. Terraform state management is crucial when manually creating resources
6. ECS Fargate provides excellent alternative to App Runner for container hosting

================================================================================
COST OPTIMIZATION NOTES:
================================================================================

CURRENT CONFIGURATION:
- ECS Fargate: 0.5 vCPU, 1GB memory (minimal cost for dev/test)
- Application Load Balancer: Pay per hour + data processed
- ECR: Storage costs for Docker images
- S3: Storage + request costs for uploaded files

PRODUCTION RECOMMENDATIONS:
- Scale ECS service based on traffic (desired_count adjustment)
- Implement auto-scaling policies for variable load
- Consider using ALB target group health checks for zero-downtime deployments
- Add HTTPS listener with SSL certificate for production use
- Implement CloudWatch alarms for monitoring and alerting

================================================================================
END OF DOCUMENTATION
================================================================================